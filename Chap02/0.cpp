
/*
#개념 정리
1.연산자 오버로딩
:기존에 정의된 연산자를 새로운 의미로 정의하는 것을 말한다.
이는 사용자가 정의한 새로운 데이터타입에 대해서 연산자 동작을
사용자가 직접 정의할 수 있게 한다.
연산자 오버로딩은 멤버함수처럼 동작하므로 프로토타입은 클래스 내부에서,
정의는 외부에서 진행한다.

연산자 오버로딩 정의는 클래스 public에서 정의되며
프로토타입은 리턴형 operator[연산자](const 클래스& other);와 같다.

2.throw 시그널을 catch하는 문법
먼저, <stdexcept> include한다.
그 다음, throw가 발생하는 코드에서
throw invalid_argument(string 문자열); 예외 발생 원인을 문자열로 작성한다.

try-catch구문에서 throw 시그널 발생시 catch가 받아서 예외를 처리한다.
예외 문구는 멤버함수인 what()을 사용하면 문자열이 출력된다.

3.Explicit declaration VS Implicit declaration
:Explicit은 내가 초기화하는거고, Implict는 컴파일러가 대신 자동으로 해준다.

4.구조체에서는 생성자, 소멸자가 없었는데 C++에서는 클래스에 의해 생성자와 소멸자가 존재한다.
생성자의 종류는 여러 개이지만, 소멸자는 오직 한 개인게 특징이다.
여러 개의 생성자 중에서 Conversion constructor를 살펴보자.

5.(중요)Conversion constructor(변환 생성자)
변환 생성자는 단 한개의 매개변수만 갖는 생성자이다.
입력된 type을 class type으로 암시적으로 변환할 수 있게 하는 특수한 생성자이다.
변환 생성자에서 매개변수의 type은 입력된 type에서 변환될 type에 해당한다.

변환 생성자 호출은
class-type 객체명 = 입력 type;이다.
입력 type을 해당 class-type으로 변환 생성자에 의해 암시적 형 변환이 일어난다.

5-1.explicit가 존재하면
class-type 객체명 = 입력 type;과 같은 코드는 에러가 발생된다.
(참고로, 변환 생성자 사용은 사용이 제한적이므로 신중하게 사용해야만 한다.)

5-2.변환 생성자는 매개변수 하나이다.

6.composition:매개변수에 기본 type이 아닌 사용자 정의 type이 들어가면
composition 되었다라고 부른다.
만약에 클래스가 들어간다면, '클래스가 재료가 되어서 composition 되었다'라고 부른다.

#다시볼 cpp 파일
(꼭 보기)4.cpp, 5.cpp : 변환 생성자 좋은 예시가 있다.

#잘 몰랐던 개념 정리
1.setw()는 한줄에 영향 주는게 아니라,
당장의 오른쪽 출력값 하나에만 영향을 준다. (?)
setw()와 left 같이 사용할 때 주의해서 사용하자.

*/