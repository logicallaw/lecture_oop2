/*
2강 개념 정리
1.표준 입출력 객체:cin(console input), cout(console output)
2.주석 사용법
3.변수 선언 및 초기화 방법
4.식별자, 키워드, 리터럴, 연산자
5.자료형(int, unsigned int, double, char, std::string, bool, void)
6.제어문자(\n, \t, \r, \b, \', \")
*/

/*
3강 새로운 개념
1.typeid(변수).name():해당 변수의 자료형의 이름을 반환한다.

2-1.할당 표현식:(변수명 = 값)으로 변수에 값을 초기화하고 바로 출력이 가능하다.
ex:
int x;
cout << (x = 3); //3

2-2.연산 우선순위

3.명시적 형변환
:C에서는 캐스팅을 (자료형)변수명으로 했지만, C++에서는 static_cast<자료형>(변수명)으로 형변환한다.

4.numeric_limits 클래스의 멤버함수
:각 멤버함수에 따라 각 자료형의 어떤 값을 반환한다.
max() 멤버함수는 해당 자료형이 표현 가능한 가장 큰 수를 반환할 것이다.

5.오버플로우와 언더플로우
:해당 자료형이 표현 불가능한 값이 되면 각각 최댓값과 최솟값은 최솟값과 최댓값으로 돌아가게 될것이다.

6.조정자(Manipulator)
-dec(10진법),oct(8진법),hex(16진법):매개변수 필요없는 진법 변환 조정자.
-10진법은 그대로, 8진법과 16진법 사용시
-showbase와 showpos는 서로간 기능이 다르다. showbase는 8진수(oct)는 0을, 16진수(hex)는 0x를 같이 출력하는 반면에
showpos는 십진수가 양수인 경우 +부호를 출력하는 기능을 수행한다.
-internal 정렬 조정자는 부호와 진법을 맨 앞으로, 수는 오른쪽으로 정렬한다.
-setw()는 그 문장(한줄)에만 예외적으로 영향준다.
-set()의 칸수보다 출력 변수의 값이 더 크거나 같으면 왼쪽부터 칸수를 무시하며 칸대로 출력한다.
-조정자 초기화 방법은 iomanip를 include하고
resetiosflags(ios_base::basefield)를 사용하면 정수 출력 관련해서만 조정자가 초기화된다.
예를 들어, showpos조정자 초기화를 원한다면 |ios_base::showpos를 해야한다.
*/

/*
실수 포인트
1.두 변수 출력시 사이의 공백을 빼먹음.
2.반올림 고려해야됨. 반올림전 double형이면서 iomanip을 include해서 setprecision을 해야됨.
만약, setprecision(0)이면 일의자리에서 반올림.
3.정수 표현식에서 '\n'은 char형이므로 아스키코드로 정수 변환 가능.
하지만, "\n"은 char 배열이므로 변환 안됨. 오류 발생함.
4.형 변환시 static_limits가 아니라 static_cast<>()임을 헷갈리면 안된다.
5.double/int하면 소수점자리까지 출력된다.

개념
1.정수이자 상수의 선언은 const 예약어 사용과 동시에 초기화해야됨.
2.switch문에서 case 표현식은 무조건 정수이자 상수여만 함. 변수가 정수이자 상수면
가능하지만, 정수지만 상수가 아니면 안된다.
그러니까, 변수가 와서 사용되려면 그 변수는 상수여만 한다.

*/

/*
개념정리
1.전위표기, 후위표기(특징:리턴값이 있다는게 새로운 사실)
-전위표기:먼저 증감후 값을 리턴함
-후위표기:리턴 먼저하고 증감함
2.'부과효과(side effect)'란?
:연산이나 표현식을 평가할 때 예상치못한 부작용이 발생하는 것을 말한다.
-예를 들면, 전위 연산자 사용시 먼저 증감 후 값을 리턴하는데 기존 변수의 값을 변경하므로 부과효과가 발생한다.
3.반복문(while, for, do~while)
-while문 종류:카운터 제어반복문(시작 전 카운터 변수 초기화, 이후 증감)
/이벤트 제어반복문(특정 이벤트 발생하면 종료)
/flag 제어반복문(1인값), infinite 제어반복문(본 강의 사용 금지)
4.for문

부족한 개념 정리
1.bool형 변수에 바로 부동소수점이 아닌 값을 입력받으면 true, false 판단하지만,
문자에 대한 처리는 iostream 헤더에 명확한 방법이 없기에 컴파일러에 따라 다르게 해석한다.
기본적으로 문자로 초기화되면 false로 아스키코드 상관없이 처리한다.
그래서, 문자로 입력하고 bool판단하고 싶으면 string변수로 먼저 받고 if~else문을 사용하여 bool를
다시 저장하는게 바람직해보인다.
2.setw 사용시 iomanip include해야됨.
3.do while문(먼저 입력받고 고려해봄)(사용자 입장에서 잘못된 값이면 다시)
4.while문 (먼저 입력받고 이후에 고려해서 실행할지 결정)(사용자 입장과 컴퓨터 입장 잘 입력해야 탈출)
5.양의 정수 do~while문 조건식이
size<0이 아니라 size < 1이어야만 한다!!
음이 아닌 정수면 0이고 양의 정수면 1이다!!
6.예외적으로
while()조건식에 (cin>>num) 사용시 올바른 정수값 입력되면 true, 정수가 아닌 값이 입력되면
false를 반환한다.
반면, 일반 변수에 (cin>>num)만 사용하면 컴파일 에러가 발생하므로
temp = static_cast<int>(cin>>num)을 사용해야지 오류가 안난다.
while조건식 예외로 알아두자.
새로운 개념
1.()초기화(C++98)
다양한 초기화 방법 중 하나이다.
int a (10) or int a = (10) 써도 되고 안써도 된다.
대입연산자 생략 가능하다.


2.{}초기화(C++11)
uniform initialization(리스트 초기화):리스트 초기화는 정확히 말하면 uniform initialization이고
이는 축소 변환시 데이터 손실을 예방할 수 있다.
-{}중괄호를 사용하여 초기화하고 축소변환이 컴파일시 일어나면 오류를 발생시켜 알려준다.
이는 더 엄격한 초기화 규칙을 따른다.
-int x = {1};로 하거나 int x{1};로 해도 된다. 대입연산자 생략해도 무관.
-일반적으로 대입연산자 생략하고 변수명{}으로 한다.

3.for조건식에서 마지막 증감값을 꼭 1씩이 아니라
+=2로도 해도됨.

4.<cmath> pow(double x, double y) : x ^ y 거듭제곱

5.for or while 반복문안의 if~else 구문에서 continue가 있으면 해당 하나의 반복문은 종료되고 이후 실행됨.
(continue아래의 코드는 실행되지 않음)

6.double형인데 소수점없는 수이고 정수처럼 출력하고 싶다면
iomanip include하고
fixed setprecision(0)하면 소수점 지워지면서 그대로 그 수를 출력함.
아니면 long long사용해서 출력하면 정수처럼 나옴.



7.반복문 제어변수 사용전 초기화!!!꼭 해야됨.

*/

/*
새로운 개념
1.함수 선언시 default값을 부여할 수 있음
(단, 함수 정의시 default값 설정은 안됨. 선언만 default 할당 가능함)
-default값이 설정된 함수를 호출할 때 일부 인수가 없어도 진행 된다는 특징.
-다만 책에서는 프로토타임(선언)과 정의 중 하나에만 default 가능하다고 함.

2.함수의 시그니처
:컴파일러가 함수를 구분하는 기준으로, 그 기준은 함수명과 매개변수목록(타입,개수,순서)로 구분함.
(단, 함수의 리턴은 시그니처에 포함 안되어있다!!!)

3.함수의 중복 정의(function overloading)
:같은 이름의 함수를 정의하는 것으로 매개변수 목록을 다르게 작성하면 가능함.
-그래서 시그니처가 다르기만 하면 중복 이름으로 다른 함수로 정의가 가능함.

4.스코프
:상수, 변수, 객체, 함수 등의 식별자가 접근할 수 있는 범위
-지역 스코프(블록 스코프):선택된 위치로부터 블록 전 영역 및 내부 블록도 접근 가능
-전역 스코프(파일 스코프):선언된 위치로부터 파일 전영역/이후 모든 블록 접근 가능
-즉, 함수 이름은 모든 부분 가능/ 함수 매개변수는 함수 내에서만 스코프

5.정적 지역 변수
static 자료형 변수명으로 선언된다.
정적 지역 변수는 선언되고 프로그램 종료되기 전까지 메모리에 남아 있다.

6.스코프 결정 연산자(::)
::변수명 사용하면 전역 변수에 접근할 수 있다.

7.기본적으로 전역에 선언된 변수는 내부 블록에서 스코프 결정 연산자::사용 안해도 접근 가능하다.
다만, 내부 블록에서 전역에 선언된 변수의 동일한 이름으로 선언이 된 변수가 존재하면
내부 블록에 선언된 변수가 우선순위이므로 그 변수를 출력하게 될거다.
이를 '변수 가려짐'(hiding)이라고 한다.

8.inline function(인라인 키워드)
인라인 키워드
:기존의 함수는 호출시 반환값이 자리를 차지하게 되는데
인라인 함수는 호출시 반환값 대신 그 자리에 함수의 본문이 들어가
그 함수의 코드가 직접 실행되므로
오버헤드(비용)를 고려해서 인라인 함수를 사용하기도 한다.
-또한, 작은 함수일수록 함수의 호출에 따른 오버헤드의 크기가 크기 때문에
인라인 함수를 사용하면 오버헤드를 줄일 수 있다.

9.피보나치수열

10.ctime 라이브러리의 자료형 clock_t
:이 자료형은 시간을 측정할 때 사용한다.
-clock_t 자료형으로 변수를 선언하고 시작을 측정할 때
clock()함수를 사용해 시작과 끝을 정하면 된다.

11.double c = 정수/정수 --> 소수점이하 안나오므로
분수의 소수 표현은 반드시 double/정수로 해야됨. 초기화되기 전에 반드시 하나는 double형이어야함

12.case식에 정수값만 오는데 "*"과 같은 배열은 못오고 무조건 '*'만 가능(정수타입)
*/

/*
개념정리

클래스와 객체는 데이터타입과 인스턴스와 관계와 유사하다(비유된다).
인스턴스는 값만 구성되지만, 객체는 값과 기능을 구성한다.
클래스를 만드는 것은 사용자 정의의 새로운 데이터타입을 생성하는 것이다.
기본 데이터타입은 하나의 값만 구성하지만, 클래스는 여러 값과 관련 기능을 추가로 포함한다.
클래스는 실체가 없고 객체는 데이터를 가진 실체가 있는 존재이다.

멤버변수(=멤버데이터, 데이터멤버, 필드, 속성)
-주로 private속성에서 선언한다.
멤버함수(=메소드, 행위)
-주로 public속성에서 선언한다.
-멤버변수에 직접 접근이 가능해, 객체와 멤버변수의 다리역할을 수행한다.
-멤버함수는 주로 클래스 외부에서 정의한다.

클래스 정의
-클래스 정의란, 새로운 데이터 타입을 작성하는 것이다.
-헤더, 본문, 세미콜론(;)으로 구성된다.

멤버변수 선언
-객체의 데이터를 저장하기 위해 선언한다.
-기본타입/사용자 정의 타입(클래스 등) 모두 사용 가능하다.

멤버함수 선언
-클래스 내부에서 멤버함수의 프로토타입만 보통 선언한다.
-멤버함수 정의는 클래스 외부에서 정의한다.

상수 멤버함수 선언
-클래스 내부에서 const를 사용하여 선언된다. 형태는 리턴타입 멤버함수명(매개변수) const {블록} 순이다.
-const는 클래스 멤버변수의 값을 함수 내부에서 변경을 허용하지 않는다.
-단, 멤버함수 내에서 선언된 지역변수의 값의 변경은 허용한다.

객체의 인스턴스화:data-type 객체명
-기존 데이터타입을 가지고 변수를 만드는 과정과 동일하다.

멤버 접근 연산자
-'.(dot)'연산자를 사용하여 특정 객체의 멤버함수를 호출한다.
-함수를 호출한 객체의 데이터를 사용하여 멤버함수가 실행된다.

접근제한자
-모든 멤버의 기본 접근 권한은 private이다.
-private속성:클래스 외부에서 직접 접근 안돼서 public 멤버함수를 통해 간접 접근한다.

setter/getter
-설정자(setter):클래스 외부에서 private 멤버변수의 값 설정을 위해 사용한다.
-접근자(getter):클래스 외부에서 private 데이터멤버의 값을 얻기 위해 사용한다.
사용목적
-클래스 외부에서 데이터를 안전하게 접근하는 법 제공
-객체지향언어에서는 데이터는 보호되어야하고, 외부에서 데이터 직접접근을 기본적으로 차단한다.
-public 데이터멤버를 사용하는 것은 효율적으로 보일지 몰라도 더 큰 문제가 발생가능하다.

생성자
-객체가 생성될때(선언) 자동으로 호출되는 멤버함수이다.
-멤버함수와 다르게 리턴 개념이 없다.

기본생성자
-객체 생성시 매개변수가 하나도 없으면 실행되는 생성자이다.
-매개변수 없는 객체 생성시 초기화 방법은 데이터타입 객체명; 또는 데이터타입 객체명{};이다.
이때, 데이터타입 객체명();은 함수의 프로토타입으로 인식하므로 아니된다.
-객체 생성은 곧 생성자를 호출하는 것이고,
생성자 호출은 객체를 생성하는 것이므로,
클래스에 명시적으로 정의된 생성자가 하나도 없으면 기본 생성자를 자동으로 컴파일러가 추가한다는게 특징이다.(시텐틱)
(다만, 기본생성자 외의 생성자가 정의되어 있으면 객체 생성시 기본생성자로 호출하면 에러가 발생한다.)

매개변수가 있는 생성자(매개변수 생성자)
-매개변수생성자는 함수처럼 동작한다.

복사생성자
-어느 한 객체를 다른 객체로 복사하는 과정에서 사용되는 생성자이다.
-반드시, 참조타입으로 만들어야한다.
-const class-type& 으로 사용해야한다.
-이때, const는 없어도 되지만, 원치않는 결과가 출력될 수 있어 보통은 복사생성자 선언시 const를 사용한다.
-참조타입은 없으면 무한로프 걸려서 참조가 반드시 있어야한다.
-복사생성자는 없으면 필요시 기본적으로 컴파일러가 기본형태는 만들어준다.

member initializer list
-생성자() : 멤버변수1{초깃값 or 변수}, 멤버변수2{...},... {}
-하는이유:const 멤버변수 초기화시 유용하다.
-멤버이니셜라이져리스트는 객체 생성되는 과정에서 실행돼서 멤버변수 생성과정에 실행된다.
그래서 private속성의 const멤버변수를 초기화가 가능해진다.
-body는 객체생성 후 실행된다.(이는 실행시간이 달라서 가능한 이야기이다.)

소멸자
-객체가 소멸 과정에서 자동으로 호출되는 멤버함수이다.
-클래스는 한개의 소멸자만 갖는다.
-리턴개념이 없고 동일한 클래스명칭에 ~만 붙인다.
-대부분 경우 자원을 반환하는 코드를 소멸자에 작성한다.

synthetic member function
기본적으로 객체 선언시 필요에 따라 클래스 내부에 해당 생성자가 존재하지 않으면
컴파일러가 아래 세가지는 해준다.
-기본생성자(클래스 내부에 생성자가 하나라도 없으면 컴파일러가 만들어준다)
-복사생성자(기본적인 형태로 만들어준다)
-소멸자(없으면 기본적으로 해주어서 현재로서는 소멸자 선언 생략해도 상관없다)
-생성자=default;는 컴파일러가 만들어주는데로 사용할 때 사용한다.
사용하는 이유는 가독성 때문에 필요하지 않은 생성자라도 default를 사용한다.
-생성자=delete;는 사용하지 않겠다고 알려주는 역할이며, 컴파일러는 해당 delete된 생성자를
자동으로 생성하지 않는다.
예전같으면 private에 생성자를 임의로 넣어서 방지했지만, c++문법 발전으로 delete를 사용한다.
-소멸자 delete하면 객체 생성 불가능하다!!!!!!
소멸자도 반드시 필요하다.

기본적으로 생성자함수와 멤버함수 형태는 비슷하다.
생성자는 리턴이 없고 멤버 초기화 리스트를 사용할 수 있다.
다만, 함수는 리턴이 있는게 특징이고 const를 사용할 수 있다.
생성자와 멤버함수 공통점은 class-type scope::name으로 호출하는게 특징이다.
*/


/*
주의사항
1.int/int-->int라서 소수점 원한다면 static_cast<int>()/int로 해야 소수점 출력됨!!!!(7-4.cpp참고) !!!!!!!(실수포인트)
*/

/*
새로운 개념
클래스타입 멤버함수(객체) const;

호출
class-type name = obj1.name(obj2);
선언
class-type name(const class-type& obj) const;
정의
class-type class-type::name(const class-type& obj) const {
	int x = _x + obj._x;
	...
}

*/
/*
실습 문제 다시볼 만한 문항
7-4.cpp:static_cast<double>(int type) / (int type)
7-9.cpp:class-type name(const class-type& obj) const; (멤버함수인데 리턴타입이 객체)
7-10.cpp:생성자 매개변수 선언에서
객체를 받고 그 객체의 default를 설정해주고 있는 상황
Line(Point p1 = Point{ 0, 0 }, Point p2 = Point{ 0 , 0 });
Line(class-type obj1 = class-type{ default1, default2 }, ... );


좋은 문제
7-2-1
7-9, 7-10, 7-11
*/